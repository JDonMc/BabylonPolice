/**
 * jQuery Formset 1.3-pre
 * @author Stanislaus Madueke (stan DOT madueke AT gmail DOT com)
 * @requires jQuery 1.2.6 or later
 *
 * Copyright (c) 2009, Stanislaus Madueke
 * All rights reserved.
 *https://github.com/elo80ka/django-dynamic-formset/blob/master/docs/usage.rst

If you have an existing project, it's quite easy to add client-side support for adding and removing forms.

I'll assume you've already created your formset. You can create formsets using any of the provided methods: both regular formsets (created with the formset_factory) and inline formsets (created with the inlineformset_factory) are supported.

First, copy jquery.formset.js to your MEDIA_ROOT; don't forget to include the jQuery library too!

Include a reference to the script in your template; again, remember to reference the jQuery library, before including the script.

Render the formset as you would normally -- I usually use a table but you can use DIVs, Ps or whatever you desire. Let's use the example markup below:

<form id="myForm" method="post" action="">
    <table border="0" cellpadding="0" cellspacing="0">
        <tbody>
            {% for form in formset.forms %}
            <tr>
               <td>{{ form.field1 }}</td>
               <td>{{ form.field2 }}</td>
               <td>{{ form.field3 }}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
    {{ formset.management_form }}
</form>
Add the following script to your template (before the closing BODY tag, or in your HEAD, below the reference to jquery.formset.js):

<script type="text/javascript">
    $(function() {
        $('#myForm tbody tr').formset();
    })
</script>
Notice that our jQuery selector targets the container for each form. We could have assigned a class to each TR and used that instead:

$('.form-container').formset();
Either way is fine, really :)

If you used a non-inline formset, you're done. Fini. Save your template and navigate to the appropriate view in your application, and you should see an "add another" link. Clicking on it should add another instance of your form to the page. You can remove instances by clicking the "remove" link for an instance.

.. versionchanged:: 1.2

   In previous versions, if there was only one form in the formset,
   the remove link would be hidden. With the addition of form templates,
   this behaviour has been changed -- it is now possible to remove all
   forms in a formset, and have the `add` link still behave as expected.


Working with Inline Formsets
..versionchanged:: 1.2

In version 1.2, the behaviour of inline formsets was changed: clicking the "remove" link for an instance in an inline formset will now cause Django to delete that instance from the database when the form is POSTed.

To enable this behaviour, you'll need to do the following:

Create an inline formset, making sure to pass can_delete=True in the call to inlineformset_factory. For more information, see the Django documentation on formsets.

Render the formset as you would normally. Be sure to include the DELETE field generated by Django, for each form with an existing instance. Here's an example:

<form id="myForm" method="post" action="">
    <table border="0" cellpadding="0" cellspacing="0">
        <tbody>
            {% for form in formset.forms %}
            <tr>
               <td>
                  {% if form.instance.pk %}{{ form.DELETE }}{% endif %}
                  {{ form.field1 }}
               </td>
               <td>{{ form.field2 }}</td>
               <td>{{ form.field3 }}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
    {{ formset.management_form }}
</form>
Notice the {% if form.instance.pk %}...{% endif %} around {{ form.DELETE }}? This is generally a good idea, since we only want Django to delete instances that already exist in the database.

Call formset in your template, making sure to set the prefix option:

<script type="text/javascript">
    $(function() {
        $('#myForm tbody tr').formset({
            prefix: '{{ formset.prefix }}'
        });
    })
</script>
Save your template and hit refresh in your browser. Try adding and removing a few rows, then submitting the page.

.. versionadded:: 1.1

Using multiple Formsets on the same page
What if you need to display more than one formset on a page? If you try the above code with more than one formset, you'll notice it doesn't work quite the way you'd expect. There are two things you need to do, in order to use more than one formset on a single page:

Give each formset a unique prefix.
Tell the plugin which forms belong to which formset -- you do this using the formCssClass option.
For example, to use the plugin with FormSet1, FormSet2 and FormSet3 on the same page, here's what you'd do:

In your view, when you instantiate each formset, pass a unique value for the prefix keyword argument:

   def my_view(request):
       if request.method == 'POST':
           formset1, formset2, formset3 = \
              FormSet1(request.POST, prefix='fs1'), \
              FormSet2(request.POST, prefix='fs2'), \
              FormSet3(request.POST, prefix='fs3')
           if formset1.is_valid() and formset2.is_valid() \
              and formset3.is_valid():
               # Do something awesome with the forms.
       else:
           formset1, formset2, formset3 = \
              FormSet1(prefix='fs1'), \
              FormSet2(prefix='fs2'), \
              FormSet3(prefix='fs3')
       ...

Giving each formset a unique prefix ensures that they don't step on each
other. For more information on ``prefix``, see the `Django documentation
<http://docs.djangoproject.com/en/dev/topics/forms/formsets/#using-more-than-one-formset-in-a-view>`.
Render the formsets in your template:

<form id="myFormsets" method="post" action="">
    <table id="myFormset1Table" border="0" cellpadding="0">
        <caption>Formset One</caption>
        <tbody>
            {% for form in formset1.forms %}
            <tr>
               <td>{{ form.field1 }}</td>
               <td>{{ form.field2 }}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
    {{ formset1.management_form }}

    <table id="myFormset2Table" border="0" cellpadding="0">
        <caption>Formset Two</caption>
        <tbody>
            {% for form in formset2.forms %}
            <tr>
               <td>{{ form.field1 }}</td>
               <td>{{ form.field2 }}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
    {{ formset2.management_form }}

    ...

</form>
Add the code to initialize the plugin for the formsets, passing a unique CSS class name to formCssClass for each formset:

<script type="text/javascript">
    $(function() {
        $('#myFormset1Table tbody tr').formset({
            prefix: '{{ formset1.prefix }}',
            formCssClass: 'dynamic-formset1'
        });
        $('#myFormset2Table tbody tr').formset({
            prefix: '{{ formset2.prefix }}',
            formCssClass: 'dynamic-formset2'
        });
        ...
    })
</script>
Save your template, hit refresh in your browser, et voila!

Formset options
You can customize this plugin's behavior by passing an options hash. A complete list of available options is shown below:

``prefix``
    Use this to specify the prefix for your formset if it's anything
    other than the default ("form"). This option must be supplied for
    inline formsets.

``addText``
    Use this to set the text for the generated add link. The default
    text is "add another".

``deleteText``
    Use this to set the text for the generated delete links. The
    default text is "remove".

``addCssClass``
    Use this to change the default CSS class applied to the generated
    add link (possibly, to avoid CSS conflicts within your templates).
    The default class is "add-row".

``deleteCssClass``
    Use this to change the default CSS class applied to the generated
    delete links. The default class is "delete-row".

``added``
    If you set this to a function, that function will be called each
    time a new form is added. The function should take a single argument,
    ``row``; it will be passed a jQuery object, wrapping the form that
    was just added.

``removed``
    Set this to a function, and that function will be called each time
    a form is deleted. The function should take a single argument,
    ``row``; it will be passed a jQuery object, wrapping the form that
    was just removed.
.. versionadded:: 1.1

    ``formCssClass``
        Use this to set the CSS class applied to all forms within the same
        formset. Internally, all forms with the same class are assumed to
        belong to the same formset. If you have multiple formsets on a single
        HTML page, you MUST provide unique class names for each formset. If
        you don't provide a value, this defaults to "dynamic-form".

        For more information, see the section on :ref:`Using multiple Formsets
        on the same page <using-multiple-formsets>`, and check out the example
        in the demo project.

.. versionadded:: 1.2

    ``formTemplate``
        Use this to override the form that gets cloned, each time a new form
        instance is added. If specified, this should be a jQuery selector.

    ``extraClasses``
        Set this to an array of CSS class names (defaults to an empty array),
        and the classes will be applied to each form in the formset in turn.
        This can easily be used to acheive row-striping effects, which can
        make large formsets easier to deal with visually.

.. versionadded:: 1.3

    ``keepFieldValues``
        Set this to a jQuery selector, which should resolve to a list of elements
        whose values should be preserved when the form is cloned.
        Internally, this value is passed directly to the ``$.not(...)`` method.
        This means you can also pass in DOM elements, or a function (in newer
        versions of jQuery) as your selector.

Note

The addCssClass and deleteCssClass 


 
 * Licensed under the New BSD License
 * See: http://www.opensource.org/licenses/bsd-license.php
 */
;(function($) {
    $.fn.formset = function(opts)
    {
        var options = $.extend({}, $.fn.formset.defaults, opts),
            flatExtraClasses = options.extraClasses.join(' '),
            totalForms = $('#id_' + options.prefix + '-TOTAL_FORMS'),
            maxForms = $('#id_' + options.prefix + '-MAX_NUM_FORMS'),
            minForms = $('#id_' + options.prefix + '-MIN_NUM_FORMS'),
            childElementSelector = 'input,select,textarea,label,div',
            $$ = $(this),

            applyExtraClasses = function(row, ndx) {
                if (options.extraClasses) {
                    row.removeClass(flatExtraClasses);
                    row.addClass(options.extraClasses[ndx % options.extraClasses.length]);
                }
            },

            updateElementIndex = function(elem, prefix, ndx) {
                var idRegex = new RegExp(prefix + '-(\\d+|__prefix__)-'),
                    replacement = prefix + '-' + ndx + '-';
                if (elem.attr("for")) elem.attr("for", elem.attr("for").replace(idRegex, replacement));
                if (elem.attr('id')) elem.attr('id', elem.attr('id').replace(idRegex, replacement));
                if (elem.attr('name')) elem.attr('name', elem.attr('name').replace(idRegex, replacement));
            },

            hasChildElements = function(row) {
                return row.find(childElementSelector).length > 0;
            },

            showAddButton = function() {
                return maxForms.length == 0 ||   // For Django versions pre 1.2
                    (maxForms.val() == '' || (maxForms.val() - totalForms.val() > 0));
            },

            /**
            * Indicates whether delete link(s) can be displayed - when total forms > min forms
            */
            showDeleteLinks = function() {
                return minForms.length == 0 ||   // For Django versions pre 1.7
                    (minForms.val() == '' || (totalForms.val() - minForms.val() > 0));
            },

            insertDeleteLink = function(row) {
                var delCssSelector = $.trim(options.deleteCssClass).replace(/\s+/g, '.'),
                    addCssSelector = $.trim(options.addCssClass).replace(/\s+/g, '.');
                if (row.is('TR')) {
                    // If the forms are laid out in table rows, insert
                    // the remove button into the last table cell:
                    row.children(':last').append('<a class="' + options.deleteCssClass +'" href="javascript:void(0)">' + options.deleteText + '</a>');
                } else if (row.is('UL') || row.is('OL')) {
                    // If they're laid out as an ordered/unordered list,
                    // insert an <li> after the last list item:
                    row.append('<li><a class="' + options.deleteCssClass + '" href="javascript:void(0)">' + options.deleteText +'</a></li>');
                } else {
                    // Otherwise, just insert the remove button as the
                    // last child element of the form's container:
                    row.append('<a class="' + options.deleteCssClass + '" href="javascript:void(0)">' + options.deleteText +'</a>');
                }
                // Check if we're under the minimum number of forms - not to display delete link at rendering
                if (!showDeleteLinks()){
                    row.find('a.' + delCssSelector).hide();
                }

                row.find('a.' + delCssSelector).click(function() {
                    var row = $(this).parents('.' + options.formCssClass),
                        del = row.find('input:hidden[id $= "-DELETE"]'),
                        buttonRow = row.siblings("a." + addCssSelector + ', .' + options.formCssClass + '-add'),
                        forms;
                    if (del.length) {
                        // We're dealing with an inline formset.
                        // Rather than remove this form from the DOM, we'll mark it as deleted
                        // and hide it, then let Django handle the deleting:
                        del.val('on');
                        row.hide();
                        forms = $('.' + options.formCssClass).not(':hidden');
                    } else {
                        row.remove();
                        // Update the TOTAL_FORMS count:
                        forms = $('.' + options.formCssClass).not('.formset-custom-template');
                        totalForms.val(forms.length);
                    }
                    for (var i=0, formCount=forms.length; i<formCount; i++) {
                        // Apply `extraClasses` to form rows so they're nicely alternating:
                        applyExtraClasses(forms.eq(i), i);
                        if (!del.length) {
                            // Also update names and IDs for all child controls (if this isn't
                            // a delete-able inline formset) so they remain in sequence:
                            forms.eq(i).find(childElementSelector).each(function() {
                                updateElementIndex($(this), options.prefix, i);
                            });
                        }
                    }
                    // Check if we've reached the minimum number of forms - hide all delete link(s)
                    if (!showDeleteLinks()){
                        $('a.' + delCssSelector).each(function(){$(this).hide();});
                    }
                    // Check if we need to show the add button:
                    if (buttonRow.is(':hidden') && showAddButton()) buttonRow.show();
                    // If a post-delete callback was provided, call it with the deleted form:
                    if (options.removed) options.removed(row);
                    return false;
                });
            };

        $$.each(function(i) {
            var row = $(this),
                del = row.find('input:checkbox[id $= "-DELETE"]');
            if (del.length) {
                // If you specify "can_delete = True" when creating an inline formset,
                // Django adds a checkbox to each form in the formset.
                // Replace the default checkbox with a hidden field:
                if (del.is(':checked')) {
                    // If an inline formset containing deleted forms fails validation, make sure
                    // we keep the forms hidden (thanks for the bug report and suggested fix Mike)
                    del.before('<input type="hidden" name="' + del.attr('name') +'" id="' + del.attr('id') +'" value="on" />');
                    row.hide();
                } else {
                    del.before('<input type="hidden" name="' + del.attr('name') +'" id="' + del.attr('id') +'" />');
                }
                // Hide any labels associated with the DELETE checkbox:
                $('label[for="' + del.attr('id') + '"]').hide();
                del.remove();
            }
            if (hasChildElements(row)) {
                row.addClass(options.formCssClass);
                if (row.is(':visible')) {
                    insertDeleteLink(row);
                    applyExtraClasses(row, i);
                }
            }
        });

        if ($$.length) {
            var hideAddButton = !showAddButton(),
                addButton, template;
            if (options.formTemplate) {
                // If a form template was specified, we'll clone it to generate new form instances:
                template = (options.formTemplate instanceof $) ? options.formTemplate : $(options.formTemplate);
                template.removeAttr('id').addClass(options.formCssClass + ' formset-custom-template');
                template.find(childElementSelector).each(function() {
                    updateElementIndex($(this), options.prefix, '__prefix__');
                });
                insertDeleteLink(template);
            } else {
                // Otherwise, use the last form in the formset; this works much better if you've got
                // extra (>= 1) forms (thnaks to justhamade for pointing this out):
                template = $('.' + options.formCssClass + ':last').clone(true).removeAttr('id');
                template.find('input:hidden[id $= "-DELETE"]').remove();
                // Clear all cloned fields, except those the user wants to keep (thanks to brunogola for the suggestion):
                template.find(childElementSelector).not(options.keepFieldValues).each(function() {
                    var elem = $(this);
                    // If this is a checkbox or radiobutton, uncheck it.
                    // This fixes Issue 1, reported by Wilson.Andrew.J:
                    if (elem.is('input:checkbox') || elem.is('input:radio')) {
                        elem.attr('checked', false);
                    } else {
                        elem.val('');
                    }
                });
            }
            // FIXME: Perhaps using $.data would be a better idea?
            options.formTemplate = template;

            if ($$.is('TR')) {
                // If forms are laid out as table rows, insert the
                // "add" button in a new table row:
                var numCols = $$.eq(0).children().length,   // This is a bit of an assumption :|
                    buttonRow = $('<tr><td colspan="' + numCols + '"><a class="' + options.addCssClass + '" href="javascript:void(0)">' + options.addText + '</a></tr>')
                                .addClass(options.formCssClass + '-add');
                $$.parent().append(buttonRow);
                if (hideAddButton) buttonRow.hide();
                addButton = buttonRow.find('a');
            } else {
                // Otherwise, insert it immediately after the last form:
                $$.filter(':last').after('<a class="' + options.addCssClass + '" href="javascript:void(0)">' + options.addText + '</a>');
                addButton = $$.filter(':last').next();
                if (hideAddButton) addButton.hide();
            }
            addButton.click(function() {
                var formCount = parseInt(totalForms.val()),
                    row = options.formTemplate.clone(true).removeClass('formset-custom-template'),
                    buttonRow = $($(this).parents('tr.' + options.formCssClass + '-add').get(0) || this),
                    delCssSelector = $.trim(options.deleteCssClass).replace(/\s+/g, '.');
                applyExtraClasses(row, formCount);
                row.insertBefore(buttonRow).show();
                row.find(childElementSelector).each(function() {
                    updateElementIndex($(this), options.prefix, formCount);
                });
                totalForms.val(formCount + 1);
                // Check if we're above the minimum allowed number of forms -> show all delete link(s)
                if (showDeleteLinks()){
                    $('a.' + delCssSelector).each(function(){$(this).show();});
                }
                // Check if we've exceeded the maximum allowed number of forms:
                if (!showAddButton()) buttonRow.hide();
                // If a post-add callback was supplied, call it with the added form:
                if (options.added) options.added(row);
                return false;
            });
        }

        return $$;
    };

    /* Setup plugin defaults */
    $.fn.formset.defaults = {
        prefix: 'form',                  // The form prefix for your django formset
        formTemplate: null,              // The jQuery selection cloned to generate new form instances
        addText: 'add another',          // Text for the add link
        deleteText: 'remove',            // Text for the delete link
        addCssClass: 'add-row',          // CSS class applied to the add link
        deleteCssClass: 'delete-row',    // CSS class applied to the delete link
        formCssClass: 'dynamic-form',    // CSS class applied to each form in a formset
        extraClasses: [],                // Additional CSS classes, which will be applied to each form in turn
        keepFieldValues: '',             // jQuery selector for fields whose values should be kept when the form is cloned
        added: null,                     // Function called each time a new form is added
        removed: null                    // Function called each time a form is deleted
    };
})(jQuery);